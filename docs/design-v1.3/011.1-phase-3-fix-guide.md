# Phase 3 Fix Guide: Test Integration & State Result Handling

**Issue**: Tests call constructs directly but constructs return state machine results  
**Root Cause**: Mismatch between construct API and test expectations  
**Solution**: Proper test helpers and state result handling  

---

## Understanding the Problem

### Current Situation

**Constructs return state results:**
```erlang
start(T) -> 
    {retry, inside, T1}.  % State machine format
```

**Tests expect simple tuples:**
```erlang
{ok, T1} = erlmd_construct_partial_data:start(T).  % Wrong!
```

### Why This Happens

The constructs are **state machine functions** that return instructions for the tokenizer's feed loop:
- `{retry, StateName, T}` - Call StateName immediately without consuming
- `{next, StateName, T}` - Consume byte then call StateName
- `{ok, T}` - Success, done
- `{nok, T}` - Failed, done

Tests can't call them directly because they need the feed loop to interpret these results.

---

## Solution 1: Test Helper with Feed Loop Simulation

Create `test/test_helper.erl` with a mini feed loop:

```erlang
-module(test_helper).
-export([
    make_tokenizer/1,
    make_tokenizer/2,
    run_construct/2,
    run_construct/3,
    feed_until_done/2
]).

-include("erlmd_types.hrl").

%% @doc Create a tokenizer with default settings.
-spec make_tokenizer(binary()) -> erlmd_tokenizer:t().
make_tokenizer(Binary) ->
    make_tokenizer(Binary, #{}).

%% @doc Create a tokenizer with custom options.
-spec make_tokenizer(binary(), map()) -> erlmd_tokenizer:t().
make_tokenizer(Binary, Options) ->
    % Create initial point
    Point = #point{line = 1, column = 1, offset = 0},
    % Create parse state
    ParseState = #{
        bytes => Binary,
        options => Options
    },
    erlmd_tokenizer:new(Point, ParseState).

%% @doc Run a construct to completion (ok or nok).
%%
%% This simulates the tokenizer feed loop for testing purposes.
%% Returns {ok, T} or {nok, T} once construct completes.
-spec run_construct(atom(), erlmd_tokenizer:t()) -> {ok | nok, erlmd_tokenizer:t()}.
run_construct(StartState, T) ->
    run_construct(StartState, T, 1000).  % Max 1000 iterations

%% @doc Run construct with max iteration limit.
-spec run_construct(atom(), erlmd_tokenizer:t(), pos_integer()) -> 
    {ok | nok, erlmd_tokenizer:t()}.
run_construct(StartState, T, MaxIter) ->
    feed_loop({retry, StartState, T}, MaxIter).

%% @doc Main feed loop - processes state results.
-spec feed_loop(state_result_tuple(), non_neg_integer()) -> 
    {ok | nok, erlmd_tokenizer:t()}.
feed_loop({ok, T}, _MaxIter) ->
    {ok, T};
feed_loop({nok, T}, _MaxIter) ->
    {nok, T};
feed_loop(_Result, 0) ->
    error(max_iterations_exceeded);
feed_loop({retry, StateName, T}, MaxIter) ->
    % Call state without consuming
    Result = erlmd_state:call(StateName, T),
    feed_loop(Result, MaxIter - 1);
feed_loop({next, StateName, T}, MaxIter) ->
    % Consume current byte, then call state
    case erlmd_tokenizer:current(T) of
        undefined ->
            % At EOF, just call the state
            Result = erlmd_state:call(StateName, T),
            feed_loop(Result, MaxIter - 1);
        _Byte ->
            % Consume and call
            T1 = erlmd_tokenizer:consume(T),
            Result = erlmd_state:call(StateName, T1),
            feed_loop(Result, MaxIter - 1)
    end.

%% Type definition for clarity
-type state_result_tuple() :: 
    {ok, erlmd_tokenizer:t()} |
    {nok, erlmd_tokenizer:t()} |
    {retry, atom(), erlmd_tokenizer:t()} |
    {next, atom(), erlmd_tokenizer:t()}.

%% @doc Feed bytes until construct completes or EOF.
%%
%% This is for integration testing where we want to parse
%% the entire input through a starting construct.
-spec feed_until_done(atom(), binary()) -> {ok | nok, erlmd_tokenizer:t()}.
feed_until_done(StartState, Binary) ->
    T = make_tokenizer(Binary),
    run_construct(StartState, T).
```

---

## Solution 2: Update All Test Modules

### Updated partial_data Tests

```erlang
-module(erlmd_construct_partial_data_test).
-include_lib("eunit/include/eunit.hrl").
-include("erlmd_types.hrl").

%% Test 1: Simple data
simple_data_test() ->
    T = test_helper:make_tokenizer(<<"Hello">>),
    T1 = erlmd_tokenizer:set_markers(T, []),
    {ok, T2} = test_helper:run_construct(data_start, T1),
    
    Events = erlmd_tokenizer:get_events(T2),
    
    % Should have enter and exit for data
    ?assertMatch([
        #event{kind = enter, name = data},
        #event{kind = exit, name = data}
    ], Events),
    
    % Should be at EOF
    ?assertEqual(undefined, erlmd_tokenizer:current(T2)).

%% Test 2: Data with line ending
data_with_newline_test() ->
    T = test_helper:make_tokenizer(<<"Hello\nWorld">>),
    T1 = erlmd_tokenizer:set_markers(T, []),
    {ok, T2} = test_helper:run_construct(data_start, T1),
    
    Events = erlmd_tokenizer:get_events(T2),
    
    % Should have: data enter/exit, line_ending enter/exit, data enter/exit
    DataEnters = [E || E <- Events, E#event.kind =:= enter, E#event.name =:= data],
    ?assertEqual(2, length(DataEnters)),
    
    LineEndings = [E || E <- Events, E#event.name =:= line_ending],
    ?assertEqual(2, length(LineEndings)).  % enter + exit

%% Test 3: Empty input
empty_data_test() ->
    T = test_helper:make_tokenizer(<<>>),
    T1 = erlmd_tokenizer:set_markers(T, []),
    {ok, T2} = test_helper:run_construct(data_start, T1),
    
    Events = erlmd_tokenizer:get_events(T2),
    
    % No data for empty input
    DataEvents = [E || E <- Events, E#event.name =:= data],
    ?assertEqual(0, length(DataEvents)).

%% Test 4: Data interrupted by marker
data_with_marker_test() ->
    T = test_helper:make_tokenizer(<<"Hello*World">>),
    T1 = erlmd_tokenizer:set_markers(T, [$*]),
    {ok, T2} = test_helper:run_construct(data_start, T1),
    
    % Should stop at the *, having parsed "Hello"
    Events = erlmd_tokenizer:get_events(T2),
    DataEvents = [E || E <- Events, E#event.name =:= data],
    ?assertEqual(2, length(DataEvents)),  % enter + exit
    
    % Should be positioned at the *
    ?assertEqual($*, erlmd_tokenizer:current(T2)).

%% Test 5: Only marker (no data before it)
only_marker_test() ->
    T = test_helper:make_tokenizer(<<"*">>),
    T1 = erlmd_tokenizer:set_markers(T, [$*]),
    {ok, T2} = test_helper:run_construct(data_start, T1),
    
    Events = erlmd_tokenizer:get_events(T2),
    
    % No data events since we immediately hit marker
    DataEvents = [E || E <- Events, E#event.name =:= data],
    ?assertEqual(0, length(DataEvents)),
    
    % Should be at the marker
    ?assertEqual($*, erlmd_tokenizer:current(T2)).

%% Test 6: Multiple lines
multiple_lines_test() ->
    T = test_helper:make_tokenizer(<<"Line1\nLine2\nLine3">>),
    T1 = erlmd_tokenizer:set_markers(T, []),
    {ok, T2} = test_helper:run_construct(data_start, T1),
    
    Events = erlmd_tokenizer:get_events(T2),
    
    % Should have 3 data chunks
    DataEnters = [E || E <- Events, E#event.kind =:= enter, E#event.name =:= data],
    ?assertEqual(3, length(DataEnters)),
    
    % Should have 2 line endings
    LineEndingEnters = [E || E <- Events, E#event.kind =:= enter, E#event.name =:= line_ending],
    ?assertEqual(2, length(LineEndingEnters)).
```

### Updated blank_line Tests

```erlang
-module(erlmd_construct_blank_line_test).
-include_lib("eunit/include/eunit.hrl").
-include("erlmd_types.hrl").

%% Test 1: Empty line (just newline)
empty_line_test() ->
    T = test_helper:make_tokenizer(<<"\n">>),
    {ok, T1} = test_helper:run_construct(blank_line_start, T),
    
    % Should succeed and be at the newline
    ?assertEqual($\n, erlmd_tokenizer:current(T1)).

%% Test 2: Line with spaces
spaces_line_test() ->
    T = test_helper:make_tokenizer(<<"   \n">>),
    {ok, T1} = test_helper:run_construct(blank_line_start, T),
    
    % Should succeed
    Events = erlmd_tokenizer:get_events(T1),
    
    % Should have space_or_tab events (consumed during attempt)
    SpaceEvents = [E || E <- Events, E#event.name =:= space_or_tab],
    ?assertMatch([_|_], SpaceEvents),
    
    % Should be at newline
    ?assertEqual($\n, erlmd_tokenizer:current(T1)).

%% Test 3: Line with tabs
tabs_line_test() ->
    T = test_helper:make_tokenizer(<<"\t\t\n">>),
    {ok, T1} = test_helper:run_construct(blank_line_start, T),
    
    % Should succeed and be at newline
    ?assertEqual($\n, erlmd_tokenizer:current(T1)).

%% Test 4: Line with content (not blank)
not_blank_test() ->
    T = test_helper:make_tokenizer(<<"  a\n">>),
    {nok, _T1} = test_helper:run_construct(blank_line_start, T).

%% Test 5: EOF after whitespace (still blank)
eof_after_whitespace_test() ->
    T = test_helper:make_tokenizer(<<"  ">>),
    {ok, T1} = test_helper:run_construct(blank_line_start, T),
    
    % Should succeed
    ?assertEqual(undefined, erlmd_tokenizer:current(T1)).

%% Test 6: EOF immediately (blank)
eof_immediately_test() ->
    T = test_helper:make_tokenizer(<<>>),
    {ok, T1} = test_helper:run_construct(blank_line_start, T),
    
    % Empty file is a blank line
    ?assertEqual(undefined, erlmd_tokenizer:current(T1)).

%% Test 7: Mixed spaces and tabs
mixed_whitespace_test() ->
    T = test_helper:make_tokenizer(<<" \t \t\n">>),
    {ok, T1} = test_helper:run_construct(blank_line_start, T),
    
    % Should succeed
    ?assertEqual($\n, erlmd_tokenizer:current(T1)).

%% Test 8: Not blank - starts with content
not_blank_content_first_test() ->
    T = test_helper:make_tokenizer(<<"abc">>),
    {nok, _T1} = test_helper:run_construct(blank_line_start, T).
```

### Updated partial_space_or_tab Tests

```erlang
-module(erlmd_construct_partial_space_or_tab_test).
-include_lib("eunit/include/eunit.hrl").
-include("erlmd_types.hrl").

%% Test 1: Single space
single_space_test() ->
    T = test_helper:make_tokenizer(<<" abc">>),
    T1 = erlmd_construct_partial_space_or_tab:space_or_tab(T),
    {ok, T2} = test_helper:run_construct(space_or_tab_start, T1),
    
    % Should have consumed space and be at 'a'
    ?assertEqual($a, erlmd_tokenizer:current(T2)),
    
    % Should have space_or_tab events
    Events = erlmd_tokenizer:get_events(T2),
    SpaceEvents = [E || E <- Events, E#event.name =:= space_or_tab],
    ?assertEqual(2, length(SpaceEvents)).  % enter + exit

%% Test 2: Multiple spaces
multiple_spaces_test() ->
    T = test_helper:make_tokenizer(<<"   abc">>),
    T1 = erlmd_construct_partial_space_or_tab:space_or_tab(T),
    {ok, T2} = test_helper:run_construct(space_or_tab_start, T1),
    
    ?assertEqual($a, erlmd_tokenizer:current(T2)).

%% Test 3: Tabs
tabs_test() ->
    T = test_helper:make_tokenizer(<<"\t\tabc">>),
    T1 = erlmd_construct_partial_space_or_tab:space_or_tab(T),
    {ok, T2} = test_helper:run_construct(space_or_tab_start, T1),
    
    ?assertEqual($a, erlmd_tokenizer:current(T2)).

%% Test 4: Mixed spaces and tabs
mixed_test() ->
    T = test_helper:make_tokenizer(<<" \t abc">>),
    T1 = erlmd_construct_partial_space_or_tab:space_or_tab(T),
    {ok, T2} = test_helper:run_construct(space_or_tab_start, T1),
    
    ?assertEqual($a, erlmd_tokenizer:current(T2)).

%% Test 5: Min/max constraints - exact count
exact_count_test() ->
    T = test_helper:make_tokenizer(<<"  abc">>),
    T1 = erlmd_construct_partial_space_or_tab:space_or_tab_min_max(T, 2, 2),
    {ok, T2} = test_helper:run_construct(space_or_tab_start, T1),
    
    ?assertEqual($a, erlmd_tokenizer:current(T2)).

%% Test 6: Min/max constraints - too few
too_few_test() ->
    T = test_helper:make_tokenizer(<<" abc">>),
    T1 = erlmd_construct_partial_space_or_tab:space_or_tab_min_max(T, 2, 4),
    {nok, _T2} = test_helper:run_construct(space_or_tab_start, T1).

%% Test 7: Min/max constraints - within range
within_range_test() ->
    T = test_helper:make_tokenizer(<<"   abc">>),
    T1 = erlmd_construct_partial_space_or_tab:space_or_tab_min_max(T, 1, 4),
    {ok, T2} = test_helper:run_construct(space_or_tab_start, T1),
    
    ?assertEqual($a, erlmd_tokenizer:current(T2)).

%% Test 8: No whitespace (should fail)
no_whitespace_test() ->
    T = test_helper:make_tokenizer(<<"abc">>),
    T1 = erlmd_construct_partial_space_or_tab:space_or_tab(T),
    {nok, _T2} = test_helper:run_construct(space_or_tab_start, T1).

%% Test 9: Whitespace at EOF
whitespace_at_eof_test() ->
    T = test_helper:make_tokenizer(<<"   ">>),
    T1 = erlmd_construct_partial_space_or_tab:space_or_tab(T),
    {ok, T2} = test_helper:run_construct(space_or_tab_start, T1),
    
    ?assertEqual(undefined, erlmd_tokenizer:current(T2)).

%% Test 10: Max limit stops consumption
max_limit_test() ->
    T = test_helper:make_tokenizer(<<"     abc">>),  % 5 spaces
    T1 = erlmd_construct_partial_space_or_tab:space_or_tab_min_max(T, 1, 3),
    {ok, T2} = test_helper:run_construct(space_or_tab_start, T1),
    
    % Should consume only 3 spaces
    Current = erlmd_tokenizer:current(T2),
    ?assertEqual($\s, Current).  % Still on space 4
```

---

## Solution 3: Simplified Integration Tests

```erlang
-module(simple_parse_integration_test).
-include_lib("eunit/include/eunit.hrl").
-include("erlmd_types.hrl").

%% Test: Parse "Hello" as data
parse_hello_test() ->
    {ok, T} = test_helper:feed_until_done(data_start, <<"Hello">>),
    
    Events = erlmd_tokenizer:get_events(T),
    
    % Check we have data events
    ?assertMatch([
        #event{kind = enter, name = data},
        #event{kind = exit, name = data}
    ], Events).

%% Test: Parse blank line
parse_blank_line_test() ->
    {ok, T} = test_helper:feed_until_done(blank_line_start, <<"  \n">>),
    
    % Should succeed (blank line detected)
    ?assertEqual($\n, erlmd_tokenizer:current(T)).

%% Test: Parse whitespace
parse_whitespace_test() ->
    Input = <<"   abc">>,
    T0 = test_helper:make_tokenizer(Input),
    T1 = erlmd_construct_partial_space_or_tab:space_or_tab(T0),
    {ok, T2} = test_helper:run_construct(space_or_tab_start, T1),
    
    % Should be positioned after whitespace
    ?assertEqual($a, erlmd_tokenizer:current(T2)).

%% Test: Data with markers
parse_with_marker_test() ->
    T0 = test_helper:make_tokenizer(<<"Hello*World">>),
    T1 = erlmd_tokenizer:set_markers(T0, [$*]),
    {ok, T2} = test_helper:run_construct(data_start, T1),
    
    % Should stop at marker
    ?assertEqual($*, erlmd_tokenizer:current(T2)),
    
    % Should have parsed "Hello"
    Events = erlmd_tokenizer:get_events(T2),
    DataEvents = [E || E <- Events, E#event.name =:= data],
    ?assertMatch([_, _], DataEvents).  % enter + exit
```

---

## Key Fixes Summary

### 1. **Test Helper with Feed Loop**
The `test_helper:run_construct/2` function simulates the tokenizer's feed loop, properly handling:
- `{retry, State, T}` - Call state immediately
- `{next, State, T}` - Consume then call state
- `{ok, T}` / `{nok, T}` - Final results

### 2. **Updated Test Pattern**
```erlang
% OLD (wrong):
{ok, T} = erlmd_construct_partial_data:start(T0).

% NEW (correct):
{ok, T} = test_helper:run_construct(data_start, T0).
```

### 3. **State Names vs Function Names**
Use **state names** (atoms) not function names:
```erlang
% Correct:
test_helper:run_construct(data_start, T)
test_helper:run_construct(blank_line_start, T)

% Wrong:
erlmd_construct_partial_data:start(T)  % Don't call directly
```

---

## Implementation Steps

### Step 1: Update test_helper.erl
Add the `run_construct/2,3` and `feed_loop/2` functions shown above.

### Step 2: Update All Test Files
Replace direct construct calls with `test_helper:run_construct/2`.

### Step 3: Verify State Dispatcher
Ensure `erlmd_state:call/2` handles all state names:
```erlang
% In erlmd_state.erl
call(data_start, T) -> erlmd_construct_partial_data:start(T);
call(data_at_break, T) -> erlmd_construct_partial_data:at_break(T);
call(data_inside, T) -> erlmd_construct_partial_data:inside(T);
% ... etc
```

### Step 4: Run Tests
```bash
rebar3 eunit --module=erlmd_construct_partial_data_test
rebar3 eunit --module=erlmd_construct_blank_line_test
rebar3 eunit --module=erlmd_construct_partial_space_or_tab_test
```

---

## Expected Results After Fix

```
✓ erlmd_construct_partial_data_test ........ (6 tests, 0 failures)
✓ erlmd_construct_blank_line_test .......... (8 tests, 0 failures)
✓ erlmd_construct_partial_space_or_tab_test  (10 tests, 0 failures)
✓ simple_parse_integration_test ............ (4 tests, 0 failures)

Total: 28 tests, 0 failures
```

---

## Additional Notes

### Why Not Call Constructs Directly?

Constructs are **internal state machine functions**, not public APIs. They:
1. Return state instructions, not final results
2. Expect the feed loop to drive them
3. May call other states via retry/next

### What About Real Usage?

In production, constructs are never called directly. The flow is:
```
erlmd:to_html(Markdown)
  → erlmd_parser:parse(...)
    → erlmd_tokenizer:feed(...)
      → Feed loop interprets state results
        → Calls constructs via erlmd_state:call/2
```

### Testing Strategy

**Unit tests**: Use `test_helper:run_construct/2` to test individual constructs  
**Integration tests**: Use full parser to test end-to-end  
**Never**: Call construct functions directly in tests

---

## Debugging Tips

### If Tests Still Fail

**Check 1**: Verify state names registered
```erlang
% All these should be in erlmd_state:call/2
data_start, data_at_break, data_inside
blank_line_start, blank_line_after
space_or_tab_start, space_or_tab_inside, space_or_tab_after
```

**Check 2**: Verify feed loop handles all result types
```erlang
feed_loop({ok, T}, _) -> {ok, T};
feed_loop({nok, T}, _) -> {nok, T};
feed_loop({retry, State, T}, N) -> ...;
feed_loop({next, State, T}, N) -> ...;
```

**Check 3**: Check max iterations
If test hangs, likely infinite loop. Increase logging:
```erlang
feed_loop({retry, StateName, T}, MaxIter) ->
    io:format("Retry: ~p (iter ~p)~n", [StateName, MaxIter]),
    ...
```

---

## Conclusion

The key insight: **constructs are state machine functions, not regular functions**. They must be called through the feed loop or a test helper that simulates it.

With these fixes:
✅ All Phase 3 tests should pass  
✅ Constructs properly integrated  
✅ Foundation ready for Phase 4  

**Next**: Once these tests pass, Phase 3 is complete and you can move to Phase 4 (Content Dispatchers).
